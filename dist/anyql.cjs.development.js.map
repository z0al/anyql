{"version":3,"file":"anyql.cjs.development.js","sources":["../src/core/internals/createAction.ts","../src/core/actions.ts","../src/core/workers/utils.ts","../src/core/internals/is.ts","../src/core/reducers.ts","../src/core/selectors.ts","../src/core/workers/query.ts","../src/core/workers/index.ts","../src/core/index.ts"],"sourcesContent":["/**\n * Copied from https://github.com/reduxjs/redux-starter-kit\n */\nimport { Action } from 'redux';\n\n// taken from https://github.com/joonhocho/tsdef\n// return True if T is `any`, otherwise return False\nexport type IsAny<T, True, False = never> = (\n  | True\n  | False) extends (T extends never ? True : False)\n  ? True\n  : False;\n\n// taken from https://github.com/joonhocho/tsdef\n// return True if T is `unknown`, otherwise return False\nexport type IsUnknown<T, True, False = never> = unknown extends T\n  ? IsAny<T, False, True>\n  : False;\n\nexport type IsEmptyObj<T, True, False = never> = T extends any\n  ? keyof T extends never\n    ? IsUnknown<T, False, True>\n    : False\n  : never;\n\n/**\n * returns True if TS version is above 3.5, False if below.\n * uses feature detection to detect TS version >= 3.5\n * * versions below 3.5 will return `{}` for unresolvable interference\n * * versions above will return `unknown`\n * */\nexport type AtLeastTS35<True, False> = [True, False][IsUnknown<\n  ReturnType<<T>() => T>,\n  0,\n  1\n>];\n\nexport type IsUnknownOrNonInferrable<T, True, False> = AtLeastTS35<\n  IsUnknown<T, True, False>,\n  IsEmptyObj<T, True, False>\n>;\n\n/**\n * An action with a string type and an associated payload. This is the\n * type of action returned by `createAction()` action creators.\n *\n * @template P The type of the action's payload.\n * @template T the type used for the action type.\n * @template M The type of the action's meta (optional)\n * @template E The type of the action's error (optional)\n */\nexport type PayloadAction<\n  P = void,\n  T extends string = string,\n  M = void,\n  E = void\n> = WithOptional<M, E, WithPayload<P, Action<T>>>;\n\nexport type PrepareAction<P> =\n  | ((...args: any[]) => { payload: P })\n  | ((...args: any[]) => { payload: P; meta: any })\n  | ((...args: any[]) => { payload: P; meta: any; error: any });\n\nexport type ActionCreatorWithPreparedPayload<\n  PA extends PrepareAction<any> | void,\n  T extends string = string\n> = WithTypeProperty<\n  T,\n  PA extends PrepareAction<infer P>\n    ? (\n        ...args: Parameters<PA>\n      ) => PayloadAction<P, T, MetaOrVoid<PA>, ErrorOrVoid<PA>>\n    : void\n>;\n\nexport type ActionCreatorWithOptionalPayload<\n  P,\n  T extends string = string\n> = WithTypeProperty<\n  T,\n  {\n    (payload?: undefined): PayloadAction<undefined, T>;\n    <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>;\n  }\n>;\n\nexport type ActionCreatorWithoutPayload<\n  T extends string = string\n> = WithTypeProperty<T, () => PayloadAction<undefined, T>>;\n\nexport type ActionCreatorWithPayload<\n  P,\n  T extends string = string\n> = WithTypeProperty<\n  T,\n  IsUnknownOrNonInferrable<\n    P,\n    // TS < 3.5 infers non-inferrable types to {}, which does not take `null`. This enforces `undefined` instead.\n    <PT extends unknown>(payload: PT) => PayloadAction<PT, T>,\n    // default behaviour\n    <PT extends P>(payload: PT) => PayloadAction<PT, T>\n  >\n>;\n\n/**\n * An action creator that produces actions with a `payload` attribute.\n */\nexport type PayloadActionCreator<\n  P = void,\n  T extends string = string,\n  PA extends PrepareAction<P> | void = void\n> = IfPrepareActionMethodProvided<\n  PA,\n  ActionCreatorWithPreparedPayload<PA, T>,\n  // else\n  IfMaybeUndefined<\n    P,\n    ActionCreatorWithOptionalPayload<P, T>,\n    // else\n    IfVoid<\n      P,\n      ActionCreatorWithoutPayload<T>,\n      // else\n      ActionCreatorWithPayload<P, T>\n    >\n  >\n>;\n\n/**\n * A utility function to create an action creator for the given action type\n * string. The action creator accepts a single argument, which will be included\n * in the action object as a field called payload. The action creator function\n * will also have its toString() overriden so that it returns the action type,\n * allowing it to be used in reducer logic that is looking for that action type.\n *\n * @param type The action type to use for created actions.\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\n */\n\nexport function createAction<P = void, T extends string = string>(\n  type: T\n): PayloadActionCreator<P, T>;\n\nexport function createAction<\n  PA extends PrepareAction<any>,\n  T extends string = string\n>(\n  type: T,\n  prepareAction: PA\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>;\n\nexport function createAction(type: string, prepareAction?: Function) {\n  function actionCreator(...args: any[]) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args);\n      if (!prepared) {\n        throw new Error('prepareAction did not return an object');\n      }\n\n      return {\n        type,\n        payload: prepared.payload,\n        ...('meta' in prepared && { meta: prepared.meta }),\n        ...('error' in prepared && { error: prepared.error }),\n      };\n    }\n    return { type, payload: args[0] };\n  }\n\n  actionCreator.toString = () => `${type}`;\n\n  actionCreator.type = type;\n\n  return actionCreator;\n}\n\n/**\n * Returns the action type of the actions created by the passed\n * `createAction()`-generated action creator (arbitrary action creators\n * are not supported).\n *\n * @param action The action creator whose action type to get.\n * @returns The action type used by the action creator.\n */\nexport function getType<T extends string>(\n  actionCreator: PayloadActionCreator<any, T>\n): T {\n  return `${actionCreator}` as T;\n}\n\n// helper types for more readable typings\n\ntype Diff<T, U> = T extends U ? never : T;\n\ntype WithPayload<P, T> = T & { payload: P };\n\ntype WithOptional<M, E, T> = T &\n  ([M] extends [void] ? {} : { meta: M }) &\n  ([E] extends [void] ? {} : { error: E });\n\ntype WithTypeProperty<T, MergeIn> = {\n  type: T;\n} & MergeIn;\n\ntype IfPrepareActionMethodProvided<\n  PA extends PrepareAction<any> | void,\n  True,\n  False\n> = PA extends (...args: any[]) => any ? True : False;\n\ntype MetaOrVoid<PA extends PrepareAction<any>> = ReturnType<\n  PA\n> extends {\n  meta: infer M;\n}\n  ? M\n  : void;\n\ntype ErrorOrVoid<PA extends PrepareAction<any>> = ReturnType<\n  PA\n> extends {\n  error: infer E;\n}\n  ? E\n  : void;\n\ntype IfMaybeUndefined<P, True, False> = [undefined] extends [P]\n  ? True\n  : False;\n\ntype IfVoid<P, True, False> = [void] extends [P] ? True : False;\n","// Ours\nimport * as t from './internals/types';\nimport { createAction } from './internals/createAction';\n\nexport const QUERY_FETCH = 'query/fetch';\nexport const queryFetch = createAction(\n  QUERY_FETCH,\n  (query: t.Query) => {\n    return { payload: { query } };\n  }\n);\n\nexport const QUERY_ERROR = 'query/error';\nexport const queryError = createAction(\n  QUERY_ERROR,\n  (query: t.Query, error: any) => {\n    return { payload: { query, error } };\n  }\n);\n\nexport const QUERY_CANCEL = 'query/cancel';\nexport const queryCancel = createAction(\n  QUERY_CANCEL,\n  (query: t.Query) => {\n    return { payload: { query } };\n  }\n);\n\nexport const QUERY_RESULT = 'query/result';\nexport const queryResult = createAction(\n  QUERY_RESULT,\n  (query: t.Query, data: t.DataObject[], next: any) => {\n    return { payload: { query, data, next } };\n  }\n);\n\nexport type Action =\n  | ReturnType<typeof queryFetch>\n  | ReturnType<typeof queryError>\n  | ReturnType<typeof queryCancel>\n  | ReturnType<typeof queryResult>;\n","// Packages\nimport * as saga from 'redux-saga/effects';\n\n// Ours\nimport * as act from '../actions';\nimport * as t from '../internals/types';\n\nexport function* cancel(query: t.Query) {\n  const actions = [act.QUERY_CANCEL];\n\n  while (true) {\n    const { payload }: act.Action = yield saga.take(actions);\n\n    if (payload.query.id === query.id) {\n      return yield true;\n    }\n  }\n}\n","// A workaround for \"anything\" but not \"undefined\"\ntype Defined =\n  | Object\n  | Array<unknown>\n  | string\n  | number\n  | boolean\n  | null;\n\nexport function defined(o: any): o is Defined {\n  return typeof o !== 'undefined';\n}\n\nexport function object(o: any): boolean {\n  return typeof o === 'object' && o !== null && !array(o);\n}\n\nexport const array = Array.isArray;\n","// Packages\nimport { combineReducers } from 'redux';\n\n// Ours\nimport * as actions from './actions';\nimport * as is from './internals/is';\nimport * as t from './internals/types';\n\nexport interface QueryData {\n  id: t.ID;\n  type?: 'query';\n  dataIds: t.ID[];\n  loading?: boolean;\n  next?: any;\n  error?: any;\n}\n\nexport interface Queries {\n  [id: string]: QueryData;\n}\n\nexport interface Objects {\n  [id: string]: t.DataObject;\n}\n\nfunction queries(state: Queries = {}, act: actions.Action): Queries {\n  switch (act.type) {\n    // query/fetch\n    //\n    // * Set query type\n    // * Set loading to true\n    // * Make sure dataIds is an array\n    //\n    // TODO: the query type should always be the same between calls\n    case actions.QUERY_FETCH: {\n      const { query } = act.payload;\n      const obj: QueryData = { ...state[query.id] } || {};\n\n      obj.id = query.id;\n      obj.loading = true;\n      obj.type = query.type || 'query';\n\n      // Make sure .dataIds is an array\n      if (!is.array(obj.dataIds)) {\n        obj.dataIds = [];\n      }\n\n      return { ...state, [query.id]: obj };\n    }\n\n    // query/error\n    //\n    // * Set error\n    // * Set loading to false\n    //\n    case actions.QUERY_ERROR: {\n      const { query, error } = act.payload;\n      const obj: QueryData = { ...state[query.id] } || {};\n\n      obj.error = error;\n      obj.loading = false;\n\n      return { ...state, [query.id]: obj };\n    }\n\n    // query/result\n    //\n    // * Merge dataIds\n    // * Set loading to false\n    //\n    case actions.QUERY_RESULT: {\n      const { query, data, next } = act.payload;\n      const obj: QueryData = { ...state[query.id] } || {};\n\n      obj.loading = false;\n      obj.next = next;\n\n      const ids = data.map(o => o.id);\n      if (is.array(obj.dataIds)) {\n        ids.push(...obj.dataIds);\n      }\n\n      obj.dataIds = Array.from(new Set(ids));\n\n      return { ...state, [query.id]: obj };\n    }\n  }\n\n  return state;\n}\n\nfunction objects(state: Objects = {}, _: actions.Action): Objects {\n  return state;\n}\n\nconst reducer = combineReducers({ queries, objects });\nexport type RootState = ReturnType<typeof reducer>;\nexport default reducer;\n","// Packages\nimport { createSelector } from 'reselect';\n\n// Ours\nimport * as t from './internals/types';\nimport { RootState } from './reducers';\n\nconst queries = (state: RootState) => state.queries;\n\nexport const queryData = createSelector(\n  queries,\n  (_: any, id: t.ID) => id,\n  (data, id) => data[id]\n);\n","// Packages\nimport * as saga from 'redux-saga/effects';\n\n// Ours\nimport * as utils from './utils';\nimport * as actions from '../actions';\nimport * as is from '../internals/is';\nimport * as select from '../selectors';\nimport * as t from '../internals/types';\n\nfunction* query(query: t.Query, runner: t.QueryRunner) {\n  const { next } = yield saga.select(state =>\n    select.queryData(state, query.id)\n  );\n\n  const options = { next };\n\n  try {\n    const task = yield saga.race({\n      result: saga.call(runner, options),\n      cancelled: saga.call(utils.cancel, query),\n    });\n\n    if (task.cancelled) {\n      return;\n    }\n\n    const result = task.result as t.QueryResult;\n    if (is.defined(result.error)) {\n      throw result.error;\n    }\n\n    // TODO: Maybe log a warning if result.data is not defined?\n    if (is.defined(result.data)) {\n      yield saga.put(\n        actions.queryResult(\n          query,\n          is.array(result.data) ? result.data : [result.data],\n          result.next\n        )\n      );\n    }\n  } catch (error) {\n    return yield saga.put(actions.queryError(query, error));\n  }\n}\n\nexport default query;\n","// Packages\nimport * as saga from 'redux-saga/effects';\n\n// Ours\nimport runQuery from './query';\nimport * as act from '../actions';\nimport * as t from '../internals/types';\n\nfunction init(resolver: t.QueryResolver) {\n  return function*() {\n    // Only listen to new requests since cancelation is\n    // handled by internally by specific workers\n    const triggers = [act.QUERY_FETCH];\n\n    // Makes sure we don't miss any action no matter what\n    const chan = yield saga.actionChannel(triggers);\n\n    while (true) {\n      const action: act.Action = yield saga.take(chan);\n\n      // Get runner\n      const { query } = action.payload;\n      const runner = yield saga.call(resolver, query);\n\n      if (action.type === act.QUERY_FETCH) {\n        yield saga.spawn(runQuery, query, runner);\n      }\n    }\n  };\n}\n\nexport default init;\n","// Ours\nimport init from './workers';\nimport reducer from './reducers';\nimport * as t from './internals/types';\n\nexport interface Options {\n  resolver: t.QueryResolver;\n}\n\nexport function createEngine({ resolver }: Options) {\n  return { reducer, engine: init(resolver) };\n}\n"],"names":["createAction","type","prepareAction","actionCreator","prepared","Error","payload","meta","error","toString","QUERY_FETCH","QUERY_ERROR","queryError","query","QUERY_CANCEL","QUERY_RESULT","queryResult","data","next","cancel","actions","act","saga","id","defined","o","array","Array","isArray","queries","state","obj","loading","is","dataIds","ids","map","push","from","Set","objects","_","reducer","combineReducers","queryData","createSelector","runner","select","options","result","cancelled","utils","task","init","resolver","triggers","chan","action","runQuery","createEngine","engine"],"mappings":"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"}