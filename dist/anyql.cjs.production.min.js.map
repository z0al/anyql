{"version":3,"file":"anyql.cjs.production.min.js","sources":["../src/core/internals/createAction.ts","../src/core/actions.ts","../src/core/workers/utils.ts","../src/core/internals/is.ts","../src/core/selectors.ts","../src/core/workers/query.ts","../src/core/workers/index.ts","../src/core/reducers.ts","../src/core/index.ts"],"sourcesContent":["/**\n * Copied from https://github.com/reduxjs/redux-starter-kit\n */\nimport { Action } from 'redux';\n\n// taken from https://github.com/joonhocho/tsdef\n// return True if T is `any`, otherwise return False\nexport type IsAny<T, True, False = never> = (\n  | True\n  | False) extends (T extends never ? True : False)\n  ? True\n  : False;\n\n// taken from https://github.com/joonhocho/tsdef\n// return True if T is `unknown`, otherwise return False\nexport type IsUnknown<T, True, False = never> = unknown extends T\n  ? IsAny<T, False, True>\n  : False;\n\nexport type IsEmptyObj<T, True, False = never> = T extends any\n  ? keyof T extends never\n    ? IsUnknown<T, False, True>\n    : False\n  : never;\n\n/**\n * returns True if TS version is above 3.5, False if below.\n * uses feature detection to detect TS version >= 3.5\n * * versions below 3.5 will return `{}` for unresolvable interference\n * * versions above will return `unknown`\n * */\nexport type AtLeastTS35<True, False> = [True, False][IsUnknown<\n  ReturnType<<T>() => T>,\n  0,\n  1\n>];\n\nexport type IsUnknownOrNonInferrable<T, True, False> = AtLeastTS35<\n  IsUnknown<T, True, False>,\n  IsEmptyObj<T, True, False>\n>;\n\n/**\n * An action with a string type and an associated payload. This is the\n * type of action returned by `createAction()` action creators.\n *\n * @template P The type of the action's payload.\n * @template T the type used for the action type.\n * @template M The type of the action's meta (optional)\n * @template E The type of the action's error (optional)\n */\nexport type PayloadAction<\n  P = void,\n  T extends string = string,\n  M = void,\n  E = void\n> = WithOptional<M, E, WithPayload<P, Action<T>>>;\n\nexport type PrepareAction<P> =\n  | ((...args: any[]) => { payload: P })\n  | ((...args: any[]) => { payload: P; meta: any })\n  | ((...args: any[]) => { payload: P; meta: any; error: any });\n\nexport type ActionCreatorWithPreparedPayload<\n  PA extends PrepareAction<any> | void,\n  T extends string = string\n> = WithTypeProperty<\n  T,\n  PA extends PrepareAction<infer P>\n    ? (\n        ...args: Parameters<PA>\n      ) => PayloadAction<P, T, MetaOrVoid<PA>, ErrorOrVoid<PA>>\n    : void\n>;\n\nexport type ActionCreatorWithOptionalPayload<\n  P,\n  T extends string = string\n> = WithTypeProperty<\n  T,\n  {\n    (payload?: undefined): PayloadAction<undefined, T>;\n    <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>;\n  }\n>;\n\nexport type ActionCreatorWithoutPayload<\n  T extends string = string\n> = WithTypeProperty<T, () => PayloadAction<undefined, T>>;\n\nexport type ActionCreatorWithPayload<\n  P,\n  T extends string = string\n> = WithTypeProperty<\n  T,\n  IsUnknownOrNonInferrable<\n    P,\n    // TS < 3.5 infers non-inferrable types to {}, which does not take `null`. This enforces `undefined` instead.\n    <PT extends unknown>(payload: PT) => PayloadAction<PT, T>,\n    // default behaviour\n    <PT extends P>(payload: PT) => PayloadAction<PT, T>\n  >\n>;\n\n/**\n * An action creator that produces actions with a `payload` attribute.\n */\nexport type PayloadActionCreator<\n  P = void,\n  T extends string = string,\n  PA extends PrepareAction<P> | void = void\n> = IfPrepareActionMethodProvided<\n  PA,\n  ActionCreatorWithPreparedPayload<PA, T>,\n  // else\n  IfMaybeUndefined<\n    P,\n    ActionCreatorWithOptionalPayload<P, T>,\n    // else\n    IfVoid<\n      P,\n      ActionCreatorWithoutPayload<T>,\n      // else\n      ActionCreatorWithPayload<P, T>\n    >\n  >\n>;\n\n/**\n * A utility function to create an action creator for the given action type\n * string. The action creator accepts a single argument, which will be included\n * in the action object as a field called payload. The action creator function\n * will also have its toString() overriden so that it returns the action type,\n * allowing it to be used in reducer logic that is looking for that action type.\n *\n * @param type The action type to use for created actions.\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\n */\n\nexport function createAction<P = void, T extends string = string>(\n  type: T\n): PayloadActionCreator<P, T>;\n\nexport function createAction<\n  PA extends PrepareAction<any>,\n  T extends string = string\n>(\n  type: T,\n  prepareAction: PA\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>;\n\nexport function createAction(type: string, prepareAction?: Function) {\n  function actionCreator(...args: any[]) {\n    if (prepareAction) {\n      let prepared = prepareAction(...args);\n      if (!prepared) {\n        throw new Error('prepareAction did not return an object');\n      }\n\n      return {\n        type,\n        payload: prepared.payload,\n        ...('meta' in prepared && { meta: prepared.meta }),\n        ...('error' in prepared && { error: prepared.error }),\n      };\n    }\n    return { type, payload: args[0] };\n  }\n\n  actionCreator.toString = () => `${type}`;\n\n  actionCreator.type = type;\n\n  return actionCreator;\n}\n\n/**\n * Returns the action type of the actions created by the passed\n * `createAction()`-generated action creator (arbitrary action creators\n * are not supported).\n *\n * @param action The action creator whose action type to get.\n * @returns The action type used by the action creator.\n */\nexport function getType<T extends string>(\n  actionCreator: PayloadActionCreator<any, T>\n): T {\n  return `${actionCreator}` as T;\n}\n\n// helper types for more readable typings\n\ntype Diff<T, U> = T extends U ? never : T;\n\ntype WithPayload<P, T> = T & { payload: P };\n\ntype WithOptional<M, E, T> = T &\n  ([M] extends [void] ? {} : { meta: M }) &\n  ([E] extends [void] ? {} : { error: E });\n\ntype WithTypeProperty<T, MergeIn> = {\n  type: T;\n} & MergeIn;\n\ntype IfPrepareActionMethodProvided<\n  PA extends PrepareAction<any> | void,\n  True,\n  False\n> = PA extends (...args: any[]) => any ? True : False;\n\ntype MetaOrVoid<PA extends PrepareAction<any>> = ReturnType<\n  PA\n> extends {\n  meta: infer M;\n}\n  ? M\n  : void;\n\ntype ErrorOrVoid<PA extends PrepareAction<any>> = ReturnType<\n  PA\n> extends {\n  error: infer E;\n}\n  ? E\n  : void;\n\ntype IfMaybeUndefined<P, True, False> = [undefined] extends [P]\n  ? True\n  : False;\n\ntype IfVoid<P, True, False> = [void] extends [P] ? True : False;\n","// Ours\nimport * as t from './internals/types';\nimport { createAction } from './internals/createAction';\n\nexport const QUERY_FETCH = 'query/fetch';\nexport const queryFetch = createAction(\n  QUERY_FETCH,\n  (query: t.Query) => {\n    return { payload: { query } };\n  }\n);\n\nexport const QUERY_ERROR = 'query/error';\nexport const queryError = createAction(\n  QUERY_ERROR,\n  (query: t.Query, error: any) => {\n    return { payload: { query, error } };\n  }\n);\n\nexport const QUERY_CANCEL = 'query/cancel';\nexport const queryCancel = createAction(\n  QUERY_CANCEL,\n  (query: t.Query) => {\n    return { payload: { query } };\n  }\n);\n\nexport const QUERY_RESULT = 'query/result';\nexport const queryResult = createAction(\n  QUERY_RESULT,\n  (query: t.Query, data: t.DataObject[], next: any) => {\n    return { payload: { query, data, next } };\n  }\n);\n\nexport type Action =\n  | ReturnType<typeof queryFetch>\n  | ReturnType<typeof queryError>\n  | ReturnType<typeof queryCancel>\n  | ReturnType<typeof queryResult>;\n","// Packages\nimport * as saga from 'redux-saga/effects';\n\n// Ours\nimport * as act from '../actions';\nimport * as t from '../internals/types';\n\nexport function* cancel(query: t.Query) {\n  const actions = [act.QUERY_CANCEL];\n\n  while (true) {\n    const { payload }: act.Action = yield saga.take(actions);\n\n    if (payload.query.id === query.id) {\n      return yield true;\n    }\n  }\n}\n","// A workaround for \"anything\" but not \"undefined\"\ntype Defined =\n  | Object\n  | Array<unknown>\n  | string\n  | number\n  | boolean\n  | null;\n\nexport function defined(o: any): o is Defined {\n  return typeof o !== 'undefined';\n}\n\nexport function object(o: any): boolean {\n  return typeof o === 'object' && o !== null && !array(o);\n}\n\nexport const array = Array.isArray;\n","// Packages\nimport { createSelector } from 'reselect';\n\n// Ours\nimport * as t from './internals/types';\nimport { RootState } from './reducers';\n\nconst queries = (state: RootState) => state.queries;\n\nexport const queryData = createSelector(\n  queries,\n  (_: any, id: t.ID) => id,\n  (data, id) => data[id]\n);\n","// Packages\nimport * as saga from 'redux-saga/effects';\n\n// Ours\nimport * as utils from './utils';\nimport * as actions from '../actions';\nimport * as is from '../internals/is';\nimport * as select from '../selectors';\nimport * as t from '../internals/types';\n\nfunction* query(query: t.Query, runner: t.QueryRunner) {\n  const { next } = yield saga.select(state =>\n    select.queryData(state, query.id)\n  );\n\n  const options = { next };\n\n  try {\n    const task = yield saga.race({\n      result: saga.call(runner, options),\n      cancelled: saga.call(utils.cancel, query),\n    });\n\n    if (task.cancelled) {\n      return;\n    }\n\n    const result = task.result as t.QueryResult;\n    if (is.defined(result.error)) {\n      throw result.error;\n    }\n\n    // TODO: Maybe log a warning if result.data is not defined?\n    if (is.defined(result.data)) {\n      yield saga.put(\n        actions.queryResult(\n          query,\n          is.array(result.data) ? result.data : [result.data],\n          result.next\n        )\n      );\n    }\n  } catch (error) {\n    return yield saga.put(actions.queryError(query, error));\n  }\n}\n\nexport default query;\n","// Packages\nimport * as saga from 'redux-saga/effects';\n\n// Ours\nimport runQuery from './query';\nimport * as act from '../actions';\nimport * as t from '../internals/types';\n\nfunction init(resolver: t.QueryResolver) {\n  return function*() {\n    // Only listen to new requests since cancelation is\n    // handled by internally by specific workers\n    const triggers = [act.QUERY_FETCH];\n\n    // Makes sure we don't miss any action no matter what\n    const chan = yield saga.actionChannel(triggers);\n\n    while (true) {\n      const action: act.Action = yield saga.take(chan);\n\n      // Get runner\n      const { query } = action.payload;\n      const runner = yield saga.call(resolver, query);\n\n      if (action.type === act.QUERY_FETCH) {\n        yield saga.spawn(runQuery, query, runner);\n      }\n    }\n  };\n}\n\nexport default init;\n","// Packages\nimport { combineReducers } from 'redux';\n\n// Ours\nimport * as actions from './actions';\nimport * as is from './internals/is';\nimport * as t from './internals/types';\n\nexport interface QueryData {\n  id: t.ID;\n  type?: 'query';\n  dataIds: t.ID[];\n  loading?: boolean;\n  next?: any;\n  error?: any;\n}\n\nexport interface Queries {\n  [id: string]: QueryData;\n}\n\nexport interface Objects {\n  [id: string]: t.DataObject;\n}\n\nfunction queries(state: Queries = {}, act: actions.Action): Queries {\n  switch (act.type) {\n    // query/fetch\n    //\n    // * Set query type\n    // * Set loading to true\n    // * Make sure dataIds is an array\n    //\n    // TODO: the query type should always be the same between calls\n    case actions.QUERY_FETCH: {\n      const { query } = act.payload;\n      const obj: QueryData = { ...state[query.id] } || ({} as any);\n\n      obj.id = query.id;\n      obj.loading = true;\n      obj.type = query.type || 'query';\n\n      // Make sure .dataIds is an array\n      if (!is.array(obj.dataIds)) {\n        obj.dataIds = [];\n      }\n\n      return { ...state, [query.id]: obj };\n    }\n\n    // query/error\n    //\n    // * Set error\n    // * Set loading to false\n    //\n    case actions.QUERY_ERROR: {\n      const { query, error } = act.payload;\n      const obj: QueryData = { ...state[query.id] } || ({} as any);\n\n      obj.error = error;\n      obj.loading = false;\n\n      return { ...state, [query.id]: obj };\n    }\n\n    // query/result\n    //\n    // * Merge dataIds\n    // * Set loading to false\n    //\n    case actions.QUERY_RESULT: {\n      const { query, data, next } = act.payload;\n      const obj: QueryData = { ...state[query.id] } || ({} as any);\n\n      obj.loading = false;\n      obj.next = next;\n\n      const ids = data.map(o => o.id);\n      if (is.array(obj.dataIds)) {\n        ids.push(...obj.dataIds);\n      }\n\n      obj.dataIds = Array.from(new Set(ids));\n\n      return { ...state, [query.id]: obj };\n    }\n  }\n\n  return state;\n}\n\nfunction objects(state: Objects = {}, _: actions.Action): Objects {\n  return state;\n}\n\nconst reducer = combineReducers({ queries, objects });\nexport type RootState = ReturnType<typeof reducer>;\nexport default reducer;\n","// Ours\nimport init from './workers';\nimport reducer from './reducers';\nimport * as t from './internals/types';\n\nexport interface Options {\n  resolver: t.QueryResolver;\n}\n\nexport function createEngine({ resolver }: Options) {\n  return { reducer, engine: init(resolver) };\n}\n"],"names":["createAction","type","prepareAction","actionCreator","prepared","Error","payload","meta","error","toString","QUERY_FETCH","queryError","query","QUERY_CANCEL","queryResult","data","next","cancel","actions","act","saga","id","defined","o","array","Array","isArray","queryData","createSelector","state","queries","_","runner","select","options","result","cancelled","utils","task","is","init","resolver","triggers","chan","action","runQuery","reducer","combineReducers","obj","_extends","loading","dataIds","ids","map","push","from","Set","objects","engine"],"mappings":"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"}